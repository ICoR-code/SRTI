<html>
	<body>
		<h2>SRTI v2.00.00 - RTI Server:</h2>
		<p>This section provides extra details on the functionality of the RTI Server.</p>
		
		<br>
		
		<h3>Brief Overview:</h3>
		<p>The <b>RTI Server</b> is an important component of the SRTI system. It acts as the single
		shared access point for multiple simulator programs to share data with each other.</p> 
		<p>It
		mimics the classic "client-server" network model, opposed to "peer-to-peer," wherein
		each simulator would be directly connected with each other; that type of system would
		be faster but more difficult to manage, and makes less sense with the "publish/subscribe"
		model involving messages rather than invoking other simulators directly. The choice to 
		subscribe to messages instead of other simulators further abstracts simulators from
		the larger system, allowing a user to easily remove or replace a simulator from the 
		system.</p>
		<img src="images/srtiv2gui_doc_v20000rtiserver_img_02.png" style="max-width:94%;margin:2%;" align="middle">
		<p>When the RTI Wrapper connects to the RTI Server on behalf of a simulator, 
		it calls a function in the RTI Lib API that sends a message on a specified network
		port number. The RTI Server must be active first to receive this message. When 
		the RTI Server receives that initial message, it creates a new dedicated thread with 
		a dedicated port number, and sends a message back on the main thread with the new
		port credentials. The RTI Lib API receives this new port and creates a new thread
		and socket itself to listen to that port. This multi-threaded approach allows
		multiple simulators to send and receive concurrent data. The RTI Server maintains
		some other basic information (like a list of messages each connected simulator 
		requested to be subscribed to), and in SRTI v2.00.00, handles basic time 
		syncronization.</p>
		<p>Individual messages are sent to and from the RTI Server in JSON format, a 
		generalized ASCII-string standard that uses key-value pairs. The RTI Server expects
		the message to contain certain keys: the important keys the user should be aware of
		are "name" and "content." "name" is an id that a simulator can subscribe to, and 
		"content" is a string that represents the data a simulator is sending. In SRTI
		v1.00.00, "content" could contain anything (the user would program what to add to it),
		but v2.00.00 expects the RTI Wrapper to fill this in automatically, and the JSON 
		format is chosen again to generate "content."</p>
		<p>When a simulator is sending a mesasge, it is generated by the RTI Wrapper, and
		sent through the RTI Lib API to the RTI Server. The RTI Server immediately parses
		out the "name" property of the message, and sends out a copy of the message to every 
		simulator that requested to be subscribed to said message. The RTI Lib API receives
		messages, and stores them in a memory buffer/cache until the RTI Wrapper retrieves
		it for use.</p>
		<p>The RTI Server was written in Java, to make it easily portable to any operating
		system that has the Java Runtime Environment (JRE) installed. It can work with 
		simulators of any language, since it relies on sockets (a cross-platform concept
		supported by many languages) for communication. The RTI Server does have the ability
		to run on a separate machine from the simulators, supporting networked distributed
		systems;
		however, disconnections can occur if the RTI Server isn't running on a static IP 
		address. If the RTI Server and RTI Lib API disconnects, they will attempt to reconnect
		to each other and resume, but if the port has changed to an unknown address, it is 
		impossible for this to work.</p>

		<br>

		<h3>System and Time Management:</h3>
		<p>Introduced in SRTI v2.00.00, the RTI Server has added the ability to maintain 
		basic time synchronization across a simulation system.</p>
		<p>A basic overview is as follows: the RTI Server decides when to request each
		connected simulator to start a given step, and will maintain an internal timestep
		virtual-clock. It will not start the simulator system until the "Send Start Request To All"
		button on the Server GUI is pressed, or until the JSON message with the name "RTI_StartSim"
		is sent to the RTI Server. At the beginning of each step, the RTI Server sends a message
		called "RTI_StartStep" to each RTI Wrapper, and in return they send "RTI_FinishStep" to
		confirmed they have completed, which includes a property to state when they individually
		expect to execute next (generally, the next immediate step, but some simulators may
		wish to execute at a different clock cycle to the rest of the simulation system).
		After receiving "RTI_FinishStep" from all simulators that had been sent "RTI_StartStep,"
		the RTI Server will check internal logic for which simulators should execute next,
		and send "RTI_StartStep" again. This process repeats until the system ends, which 
		occurs when the RTI Server is manually closed, or when an RTI Wrapper sends a message
		confirming the system should end (based on a specified simulator criteria being met).</p>
		
		<br>

		<h3>How To Use (Launch, Server GUI):</h3>
		<img src="images/srtiv2gui_doc_v20000rtiserver_img_01.png" style="max-width:94%;margin:2%;" align="middle">
		<p>Download the RTI Server executable file. See the HTML Documentation page for 
		<b>How To Install / Download</b> for more information. The RTI Server is contained 
		within an executable .jar file named something like "SRTI_v2_22_02.jar." This
		file also happens to contain the RTI Lib API that a program could access directly
		to connect with the SRTI system.</p>
		<p>If not already installed, download the <b>Java Runtime Environment (JRE)</b>
		prior to trying to start the RTI Server.</p>
		<p>To start the RTI Server, you can simply double-click on the .jar file, like
		you would for any application. You may also start the RTI Server from a command
		line / terminal using a standard command. It is possible to have multiple
		instances of an RTI Server open at once (each on a separate port number),
		but if trying this, we recommend copying the .jar file to different 
		directories, to prevent the liklihood that one simulation system will
		interfere with another.</p>
		<p>By default, when you start the RTI Server, a basic Server GUI written in 
		the Java Swing framework will appear. It shows the computer's IP address and
		the RTI Server's public port number; these credentials need to be used for
		a simulator (RTI Wrapper) to connect successfully to this instance of an SRTI.
		This GUI will also update with information on connected simulators and received
		messages. When closing this Server GUI, the backend RTI Server also closes,
		disconnecting any active simulators. Despite being included in the same package
		as the core RTI Server, the Server GUI is treated as an external process,
		and acts a simulator itself, connecting the to RTI Server and subscribing to all
		messages (and not publishing any messages). Therefore, you should see it listing
		itself as a "connected app" immediately upon launch.</p>
		<p><b>This Server GUI has been known to have bugs that include not 
		correctly refreshing a list of connected simulators, or showing a simulator
		as still connected after it has disconnected.</b> Some of these bugs occur with
		simulators in different languages. Generally, these issues can be ignored,
		but closing and restarting the RTI Server will typically resolve the problem.</p>
		<p>Modifying or understanding the source code shouldn't be required, but for 
		experienced developers, the source code for the RTI Server (Java)
		can be found here: 
		<a href="https://github.com/ICoR-code/SRTI/tree/master/SRTI_Source/v1_v2_Java_Server_Client_Source/SRTI_v2_00_00" target="_blank">
		https://github.com/ICoR-code/SRTI/tree/master/SRTI_Source/v1_v2_Java_Server_Client_Source/SRTI_v2_00_00</a>. 
		<b>ExampleServer.java</b> is the main class for the RTI Server.</p>
		
		<br>
		
		<h3>Settings.txt File:</h3>
		<p>The RTI Server makes use of an optional "Settings.txt" file. The RTI Server
		will search it's local directory for a file of that exact name before launching.
		It includes the ability to set a preferred port number (without this, the RTI 
		Server will launch on a random available port), which makes it valuable for 
		repeated testing.</p>
		<p>The Settings.txt file is saved as a .txt file, but is formatted as JSON.
		An example file can be found at the following link: 
		<a href="https://github.com/ICoR-code/SRTI/blob/master/SRTI_Compiled/SRTI_v2_00_00/build/settings.txt" 
		target="_blank">https://github.com/ICoR-code/SRTI/blob/master/SRTI_Compiled/SRTI_v2_00_00/build/settings.txt</a>.
		That example can be seen below:</p>
		<code>
{
    "portNumber": 42012,
    "guiOn": true,
    "debugGuiOn": false,
    "tcpOn": false,
    "compressOn": false,
    "retryConnection": false,
    "oldMessageLimit": 10000,
    "oldMessageArchive": false,
    "debugConsole": true,
    "debugFile": true,
    "concurrentProcessing": true,
    "oldMessageGUILimit": 10
}</code>
		<p>The properties include:</p>
		<ul>
			<li><b>"portNumber"</b>: [<i>integer</i>], a preferred port number to open the RTI Server on.</li>
			<li><b>"guiOn"</b>: [<i>true, false</i>], choose to open or hide the Server GUI on launch.</li>
			<li><b>"debugGuiOn"</b>: [<i>true, false</i>], choose to open (depricated) GUI that displays debug 
			logs in real time, including basic filter features.</li>
			<li><b>"tcpOn"</b>: [<i>true, false</i>], choose for the RTI Server to require a confirmation message
			from the destination that a message was received properly. The SRTI already uses TCP
			Sockets for communication, but this enables an extra layer to confirm messages were
			received as expected. If this is enabled, messages that don't get confirmed as received 
			are sent again after a short delay, up to 3 times. This feature can slow down an
			SRTI system slightly.</li>
			<li><b>"compressOn"</b>: [<i>true, false</i>], not implemented, but intended to allow messages to be
			compressed to reduce the amount of data being sent with socket communication.</li>
			<li><b>"retryConnection"</b>: [<i>true, false</i>], not implemented, individual RTI Lib API will 
			automatically try to reconnect if connection is disruptted.</li>
			<li><b>"oldMessageLimit"</b>: [<i>integer</i>], determines how many bytes of messages should be stored
			in RAM memory, in case a message needs to be resent,
			before the cache is cleared.</li>
			<li><b>"oldMessageArchive"</b>: [<i>true, false</i>], determines if cleared message cache should
			be stored in local files on hard disk for access into RAM later, should resending 
			message be required, or should a late simulator join an SRTI system and request
			message history (relevant for SRTI v1.00.00, less so for v2.00.00).</li>
			<li><b>"debugConsole"</b>: [<i>true, false</i>], if running from command line, this feature enables
			printing debug logs to console terminal. Does not do anything if RTI Server was 
			not launched from command line. This feature can slow down an
			SRTI system slightly.</li>
			<li><b>"debugFile"</b>: [<i>true, false</i>], this feature enables
			printing debug logs to log files in the sam directory as the RTI Server. 
			This feature can slow down an SRTI system significantly.</li>
			<li><b>"concurrentProcessing"</b>: [<i>true, false</i>], this feature enables
			concurrent thread access for the RTI Server to send and receive messages 
			from individual simulators. Setting to 'true' executes faster, but may not
			be thread-safe. See source code for details.</li>
			<li><b>"oldMessageGUILimit"</b>: [<i>integer</i>], limits how many messages can be seen in
			Server GUI. Setting this number to be too high can cause issues with the GUI.</li>
		</ul>
	
	</body>
</html>